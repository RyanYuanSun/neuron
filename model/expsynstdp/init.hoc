/*
Tests expsynstdp.mod by running a series of experiments to determine
the relationship between tpre-tpost and the degree of (de)potentiation.
*/

// tpre-tpost is varied from -TPOST to +TPOST
TPOST = 40 // time of postsynaptic spike
TESTLATENCY = 20 // test pulse is applied TESTLATENCY after 2*TPOST
      // so g elicited by the conditioning input has time to decay 

load_file("nrngui.hoc")

///// model cell
create soma
access soma
L = 10
diam = 100/L/PI
insert pas

///// instrumentation

// synapse
objref syn
syn = new ExpSynSTDP(0.5)
syn.tau = 1
// these values are Bi & Poo's estimates of the effect of a single spike pair
syn.d = 0.0053
syn.p = 0.0096
/*
// these values will produce, with a single spike pair,
// depression or potentiation equal to that which Bi & Poo saw
// after 60 spike pairs
syn.d = 0.273
syn.p = 0.777
*/

// postsynaptic depol:  to 30 mv x 0.1 ms at TPOST
objref sec
sec = new SEClamp(0.5)
sec.rs = 1e-3
sec.dur1 = TPOST
sec.amp1 = -65
sec.dur2 = 0.1
sec.amp2 = 30 // mV peak depol
sec.dur3 = 1e9
sec.amp3 = -65

/*
|<------tcond------>|
0---------1---------2---------3
          ^tpost              ^ttest
0     time at which NetStim fires
0..2  interval in which conditioning event is delivered by nc[0]
1     time at which postsynaptic cell is depolarized by the SEClamp
3     time at which the test event is delivered by nc[1]

Conditioning and test inputs to the synaptic mechanism 
are events that are delivered at user-specified times
tcond and ttest.

+--- ns ---+
|          |
| nc[0]    | nc[1]
|          |
+--> pre <-+
      |
      | nc[2]
      |
      +--> syn

These are generated by a single NetStim that fires at t=0 and
drives two NetCons that are attached to an IntFire1 (called pre).
nc[0] delivers the conditioning pulse at 0<= tcond <= 2*tpost
nc[1] delivers the test pulse at 3*tpost.
Both have weight 2 so they drive the IntFire1 above threshold.
The IntFire1's refrac parameter is set to 0, so it fires 
immediately in response to each event.
Consequently its output is an OR of its inputs.

The IntFire1 in turn drives the synapse with NetCon nc[2]
with user-specified weight and delay 0.
*/

objref ns, nc[3], pre
ns = new NetStim()
ns.number = 1
ns.start = 0
ns.noise = 0
pre = new IntFire1()
pre.refrac = 0

for i=0,1 {
  nc[i] = new NetCon(ns, pre)
  nc[i].weight = 2
  nc[i].delay = 1+i*10 // just for testing
    // actual values specified in simulation control block
}

nc[2] = new NetCon(pre,syn)
nc[2].weight = 1e-3
nc[2].delay = 0


///// simulation control

load_file("rig.ses")

tstop = 2*TPOST+TESTLATENCY
nc[1].delay = tstop-1 // long after conditioning

///// generate plot of max synaptic weight vs. pre-post latency

objref gvec,tvec,tprepost,gmax
gvec = new Vector() // will be time course of synaptic conductance
gvec.record(&syn.g)
tvec = new Vector()
tvec.record(&t)
tprepost = new Vector() // will contain tpre-tpost values
gmax = new Vector() // will contain peak synaptic conductances after STDP

nc[2].weight=1 // so the gmax elicited by a test response
    // reveals the current degree of potentiation or depression
    // a naive synapse should generate gmax==1

// nc[0] delivers the conditioning pulse at various times
// nc[1] delivers the test pulse at fixed time (59 ms)

objref g, sfvec

// wrap the NMODL-defined FUNCTION in a hoc function
// so it can be passed to Vector.apply--see below
func factor() {
  return syn.factor($1)
}

// proc plotresults() { local Dt
proc plotresults() {
  g = new Graph()
  gmax.plot(g, tprepost)
  g.exec_menu("View = plot")
  // calculate the potentiation factors expected from the tpre-tpost values
  // and plot them on top of the peak g values
  sfvec = new Vector()
  sfvec=tprepost.c()
  /*
  Vector class's apply() method requires the name of a hoc function
  as its argument.  Trying to pass it the name of an NMODL-defined 
  function, e.g. "syn.factor", generates an "undefined function"
  error message.  The workaround is to wrap the NMODL-defined 
  function in a hoc function.
  */
  sfvec.apply("factor")
  sfvec.plot(g, tprepost, 2, 6) // red, dotted
}

proc batrun() { local i, j
  tprepost = new Vector()
  gmax = new Vector()
  for i=0,2*TPOST {
    nc[0].delay = i
    run()
    tprepost.append(TPOST-nc[0].delay)
    // find max g after g elicited by conditioning input has decayed
    j = tvec.indwhere(">",2*TPOST+TESTLATENCY/2)
    gmax.append(gvec.max(j, gvec.size()-1))
  }
  plotresults()
}

batrun()

